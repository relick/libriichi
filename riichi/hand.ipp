#pragma once

#include "hand.hpp"

#include <algorithm>
#include <ranges>

namespace Riichi
{

HandAssessment::HandAssessment
(
	Hand const& i_hand
)
{
	// Make a temporary list of all tiles in the hand that we can use for quickly assessing
	std::vector<Tile> tilesInHand = i_hand.FreeTiles();

	// At the same time, make any meld-specific assessments
	for ( Meld const& meld : i_hand.Melds() )
	{
		tilesInHand.insert_range( tilesInHand.end(), std::views::elements<0>( meld.m_tiles ) );

		m_open |= meld.m_open;
	}

	// Now assess individual tiles
	for ( Tile const& tile : tilesInHand )
	{
		m_containsTileType[ tile.Type() ] = true;

		if ( tile.Type() == TileType::Suit )
		{
			SuitTile const& suitTile = tile.Get<TileType::Suit>();
			m_containsSuit[ suitTile.m_suit ] = true;
			if ( suitTile.m_value == 1 || suitTile.m_value == 9 )
			{
				m_containsTerminals = true;
			}
			break;
		}
	}

	m_containsHonours = m_containsTileType[ TileType::Dragon ] || m_containsTileType[ TileType::Wind ];

	// Finally, make possible hand interpretations
	// Start by setting up the fixed part determined by the melds
	HandInterpretation fixedPart;
	for ( Meld const& meld : i_hand.Melds() )
	{
		HandInterpretation::Group& group = fixedPart.m_groups.emplace_back();
		group.m_tiles.reserve( meld.m_tiles.size() );
		group.m_tiles.insert_range( group.m_tiles.end(), std::views::elements<0>( meld.m_tiles ) );
		group.m_type = meld.m_type;
		group.m_open = meld.m_open;
	}

	// Aim: calculate all possible arrangements that could form (part of) a winning hand, excluding special arrangements (13 orphans + 7 pairs)
	// Need to do this without repeating any arrangements, nor any permutations of arrangements
	// e.g. if there's 3445, then 345 + 4 and 44 + 35 should be the only two arrangements
	// or if there's 123456, then 123 456, 234 + 156, 345 + 126, should be the only three arrangements.
	// This is quite tricky, as evidently, some tiles will be part of multiple groups so simply recursively enumerating every tile will generate a lot of repeats.
	// Option 1 is the simple bruteforce: generate all arrangements, excluding those with fewer groups than available, then eliminate duplicates
	// Option 2:
	// Recursively enumerate, with the rules:
	/// Arrangements selected greedily i.e. if a group is present, it is always included, and only excluded if that would allow another group to form
	/// sequences are only generated numerically upwards from the given tile
	/// pairs/triplets are only generated to the right from the given tile
	/// duplicates of 'earlier' tiles are skipped if the earlier tile was marked as ungrouped
	// This should generate identical arrangement sets to option 1
	// Proof:
	// Suppose there's an arrangement A that is generated by 1 but not by 2.
	// This means it must contain a group G that is not present in any arrangement generated by 2
	// Such a group would have been generated in contradiction to one of the rules of 2:
	/// if it's a sequence that's below an assessed tile, this couldn't happen because the lower tile would've been assessed at some point
	/// if it's a pair/triplet that's to the left of a given tile, again can't happen because the left tile would've been assessed first
	/// if it's because it's including a tile skipped due to being a duplicate, this can't be right, as such a tile would only be skipped if already marked ungrouped
	// FWIW most hands will collapse to just a couple of interpretations pretty quick
	// and there is a small upper limit to the number of possible arrangements as they are always as greedy as possible:
	// about 4 or so
	// The main tricky part of this is working out which arrangements are 'degenerate' i.e. strictly weaker than another arrangement
	// the principle is that if ungrouping a tile allows another group to be made, then that arrangement is 'good'
	// but this isn't global. A hand with a 4 sequence arrangement and a 3 triplet arrangement has 2 good arrangements
	// Okay I think I just need to make the baseline bruteforce to test against

	m_interpretations = GenerateInterpretations( fixedPart, i_hand.FreeTiles() );
}

/*static*/ std::vector<HandInterpretation> HandAssessment::GenerateInterpretations
(
	HandInterpretation const& i_fixedPart,
	std::vector<Tile> const& i_freeTiles
)
{
	std::vector<HandInterpretation> interpretations;

	auto fnGenerate = [ & ]()
	{

	};

	auto fnEliminate = [ & ]()
	{

	};

	fnGenerate();
	fnEliminate();

	return interpretations;
}

}